# 前書き #

## このファイルについて ##

このファイルで同梱のソースをどうやって読むのかを解説します。

文書自体は[Markdown](http://qiita.com/Qiita/items/c686397e4a0f4f11683d)で
書かれています。

## 実行(表示)できる環境 ##

Firefoxでテストをしています。
おそらくChromeでも実行できるでしょう。

MS EdgeとIEでは実行できません。Vivaldiも無理です。

## ファイルの構成について ##

* calc.html - メインの表示を行なうhtml(html5)ファイルです。
* test.html - テストスイートの実行を行なうファイルです。このファイルを表示させることで計算部分のテストを行ないます。
* docs/ - ソースに付随する文書を保管するディレクトリです。
 - howtoread.md - このファイルです。
* js/ - 実行に必要なJavascriptのファイルを保管するディレクトリです。
 - calc.js - 計算機のメインとなるファイルです。仕様については後述。
 - manupulate_form.js - htmlのフォームから値を読みこみcalc.jsに渡すためのファイルです。
 - test - テスト(動作が仕様にそっているかをチェックする)用のディレクトリです。
  - test.js - テストケースが書かれたファイルです。test.htmlから実行されます。
* data/ - Javascriptファイルから読みこまれるデータが置かれたディレクトリです。
 - job_data.json - ジョブとそれに付随する計算用の情報が書かれたファイルです。
* css/ - 表示のためのスタイルシートが置かれたディレクトリです。
* .gitignore - Git(バージョン管理用のソフトウェア)で使われる無視するファイル名の一覧が書かれたファイルです。

# ソースの読み方 #

## 全体的な考え方

今回は計算機部分が単体でテストできるような仕様を考えていました。

そのためには計算機部分のフォームからの読みとり部分と、実際に計算をする部分を分ける必要があります。なぜなら、テストは外部から関数を呼びだしその値をチェックする形で実行されることが多いために、前述の2つが密接に結びついていると単体テストが困難になるためです。

結果、以下のような流れになりました。

* htmlのフォームから入力された値を読みこむ。
* 読みとられた値をオブジェクト(辞書)として計算機部分に渡す。
* 計算機部分で計算された値を戻り値として受けとり、表示を更新する。

## ソースを書くときの考え

単なる写経ですと書いていてあんまり面白くないですし、
「こうやったら面白い」という提案としても微妙です。

ですから、
Firefox(とChrome)で使える現代的なJavascriptを可能な限り使ってみました。
その結果、他のブラウザで実行できない部分がものすごく増えましたが…。

各ブラウザでどの機能が使えるかどうかは、[MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript)の
リファレンスが便利です。

なお、どのソースも基本的に以下の仕様に沿って書かれています。

* インデントはスペース
* 1つのインデントは2つのスペース
* htmlのタグは全て小文字
* あとは感じろ

## calc.jsの解説

calc.jsの仕様については前述しましたが、
可能な限り表示部分のコードに依存しない形で書きました。

それを前提にして読んでいただければ幸いです。

### 計算部分 `function calculate_atkval`

計算機の本体部分になります。

2つの引数、つまり計算するためのパラメータオブジェクトとジョブの仕様が書かれたオブジェクトを受けとり、戻り値として基本攻撃力、表示攻撃力、計算攻撃力が格納されたオブジェクトを返します。
引数として受けとるオブジェクトの仕様についてはソースにコメントとして書きましたので参考にしてください。

#### 召喚加護の値を合計する

まず戸惑うかもしれないのが、Javascriptのオブジェクト(`{}`で囲まれたアレ)の仕様かもしれません。

Javascriptのオブジェクトの基本は`{ キー: 値, ... }`で示される連想辞書です。

オブジェクトについては参照の仕方がいくつかあります。
`var o = { "attribute": 1 };`(もしくは`var o = { attribute: 1 };`)と書かれた時、
このオブジェクトのattributeの値は`o.attribute`か`o["attribute"]`として参照できます。
つまり、文字列が代入された変数を使っても参照することができるのです。
これを利用したのが`var divine_percent = { ... };`の部分です。

次の部分ですが、`param_obj.summon`は配列が入っていることが想定されています。

配列に関しては`forEach`というメソッドが存在します。
このメソッドは引数として関数を受けとり、その関数に要素を渡して実行します。
以下のコードを実行してみるとわかりやすいでしょう。

```
var ary = [1, 2, 3, 4, 5];
ary.forEach(function(d) {  // 関数に名前を付けない場合、その場で一時的に定義されます
  console.log(d);
});
```

もちろんこれは次のように書いても同じ動作をします。

```
function pr(val) {
  console.log(val);
}

var ary = [1, 2, 3, 4, 5];
ary.forEach(pr);
```

#### (武器|召喚)攻撃力の計算 (無名関数の即時実行)

武器攻撃力と召喚攻撃力を算出している部分ですが、
ここでは無名の関数を定義して、即時に実行しています。

関数は定義された範囲内でスコープを持ち、
**その時に定義されている外部の環境を取りこみ**ます。
今回はスコープを分割するために無名関数を使っていますが、
後々後者の特徴を使います。

今回のこの部分については、以下のように分割するとわかりやすいかと思います。

```
var f = function() {
  console.log("Hello, World!");
};
f();
```

#### 武器ごとのスキル計算 (関数のテーブルとarrow function)

計算機部分で一番長いのが、この部分、武器ごとのスキルを計算するところです。

まず、元になったソースを見てみると、以下のような部分が続きます。

```
      if (skill_type == "kj1") {
				if (skill_level < 10) {
					total_koujin_percent += 0 + skill_level;
				} else {
					total_koujin_percent += 10 + (skill_level - 10) * 0.4;
				}
			}
			if (skill_type == "kj2") {
				if (skill_level < 10) {
					total_koujin_percent += 2 + skill_level;
				} else {
					total_koujin_percent += 12 + (skill_level - 10) * 0.5;
				}
			}
```

まず、次のようなパターンになると気付きます。

```
if (skill_type == "なんちゃら"){
  処理;
}
```

これはこのように書きかえられます。

```
var func_table = {
  "なんちゃら": function() { 処理; }
};
func_table["なんちゃら"] ();
```

こうすることでif部分のタイプ量を減らせます。

そして、メインとなる処理の部分は次のようなパターンになっています。

```
if (レベル判定) {
  変数 += 式1;
} else {
  変数 += 式2;
}
```

これを楽に書こうとしたのが`pfunc_gen`です。
この関数は**関数を返す関数**です。
引数として、"代入する変数のキー"、"levelを受けとり判定する関数"、
"levelを受けとり式1の結果を返す関数"、"levelを受けとり式2の結果を返す関数"
を取ります。
なぜ第1引数として普通に代入する対象の変数を取らなかったかというと、
それは明示的に参照渡しをする方法がわからなかったからです。

ソースを参照しながら見ていただきたいですが、
`pfunc_gen`を使うと、先の`"kj1"`の処理は次のように書けます。

```
var total_skill = { koujin: {percent: 0} };

function pfunc_gen( ... ) {
  ...
}

var func_table = {
  "kj1": pfunc_gen(
    "koujin",
    function(level) { return level < 10; },
    function(level) { return 0 + level; },
    function(level) { return 10 + (level - 10) * 0.4; }
  )
};
// func_table["kj1"](15); として使う
```

ちなみに、`total_skill`のあとで`pfunc_gen`を定義している理由ですが、
これは**関数が定義された時点での環境を取りこむ**ためです。

判定関数と式を計算する関数を一般化したのが、`less_than_chklv`と`pcalc_gen`になります。

これで関数テーブルのほとんどの部分を解説しましたが、
まだ背水("bw1"とか)の部分にある`(l) => ( なんちゃら )`について解説していないので、
軽く書きます。

これは比較的新しいブラウザで使える表記で、
[arrow function](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/arrow_functions)というものです。
細かい違いはありますが、次の2つはだいたい同じ動作をします。
```
var tmp1 = function(i) { return i + 10; };  // iを引数に取りi+10を返す関数
var tmp2 = (i) => (i + 10);

console.log(tmp1(10));  // 20
console.log(tmp2(10));  // 20
```

#### 最終結果の計算

丸める部分についてはここにまとめました。

計算の式は同じようにしたつもりですが、違いがあるかもしれません。

### 関数`get_job_data` (Promise)

関数`get_job_data`は指定されたURLからJSONデータを読みこみ、
job_dataに格納する関数です。
ここではJavascriptの新しい仕組みのPromiseを使っています。

Javascriptで注意したいのは、
ファイルの読みこみなどの実行時間がかかる関数は**非同期実行される**ことが多いのです。
つまりどういうことかと言うと、
非同期実行される関数は呼びだされてその場で待つのではなく、
実行を継続して、処理が完了したら指定された関数を呼びだすのです。

処理時間がかかる関数の例として、
[jQueryのget](http://semooh.jp/jquery/api/ajax/jQuery.get/+url,+data,+callback+/)関数を見てみましょう。

```
$.get("test.php", function(data){
  console.log(data);
});
```

これは単純な例なのでこれだけですんでいますが、
例えば「test.phpを読みこんだあとにtest2.phpを読みこむ」という処理だとこうなるでしょう。

```
$.get("test.php", function(data){
  console.log(data);
  $.get("test.php", function(data) {
    console.log(data);
  });
});
```

だんだんネストが深くなっていって嫌になっていきます。
これを簡単に書けるようにするのが**Promise**(あるいはFuture)と呼ばれるものです。

先程の処理はjQueryだと次のようにも書けます
( [jQuery.get](https://api.jquery.com/jquery.get/) )。

```
$.get("test.php", function(data) {
  console.log(data);
}).done(function(data) {
  console.log(data);
});
```

ネストが深くなることも無く、しかもわかりやすくなりました。

この処理をjQueryを使わずに書いたのが該当関数です。
ここでは[Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)を
使っています。
http://jxck.hatenablog.com/entry/whatwg-fetch も参考にしてください。

## manupulate_form.jsの解説


### フォームからの値の取りこみ

もうがんがんとjQueryを使っています。
`$(なんちゃら).val()`でなんちゃらの値を取りだせるのが重要ですが、
問題はなんちゃらの部分でどうやって要素を指定する(セレクタ)かです。

これはFirefoxなどに搭載されている「開発者ツール」(大抵はF12で起動する)を使うとわかりやすいです。
Firefoxの場合、F12の*インスペクタ*左上にある「ページから要素を選択」のボタンを押すと、
どこがどのような文字列で表現されるかが出てきます。

jQueryの`each`と`find`も覚えておきたいところです。
前者は指定された要素1つごとに関数を実行するものです。後者は指定された要素の子孫要素全てを検索する関数です。

### テンプレート文字列

テンプレート文字列は複数行の文字列を作るだけではなく、
文字列の間で変数を展開することが出来ます。
以下の例をご覧ください。

```
var name = "EIRIIINNNNNNNN!!!"
var s = `Help me, ${name}`;
console.log(s);`
```


# 終わりに #

付属のテストケースの説明はしてない上に
全体にバグが多々残っていると思いますが、
おおよその解説は出来たかと思います。

参考になれば幸いです。
